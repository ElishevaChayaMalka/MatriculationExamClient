var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const mapData = (() => {
  const storeData = {};
  let id = 1;
  return {
    set(element2, key, data) {
      if (typeof element2[key] === "undefined") {
        element2[key] = {
          key,
          id
        };
        id++;
      }
      storeData[element2[key].id] = data;
    },
    get(element2, key) {
      if (!element2 || typeof element2[key] === "undefined") {
        return null;
      }
      const keyProperties = element2[key];
      if (keyProperties.key === key) {
        return storeData[keyProperties.id];
      }
      return null;
    },
    delete(element2, key) {
      if (typeof element2[key] === "undefined") {
        return;
      }
      const keyProperties = element2[key];
      if (keyProperties.key === key) {
        delete storeData[keyProperties.id];
        delete element2[key];
      }
    }
  };
})();
const Data$1 = {
  setData(instance, key, data) {
    mapData.set(instance, key, data);
  },
  getData(instance, key) {
    return mapData.get(instance, key);
  },
  removeData(instance, key) {
    mapData.delete(instance, key);
  }
};
const toType$1 = (obj) => {
  if (obj === null || obj === void 0) {
    return `${obj}`;
  }
  return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
};
const getSelector$1 = (element2) => {
  let selector = element2.getAttribute("data-mdb-target");
  if (!selector || selector === "#") {
    const hrefAttr = element2.getAttribute("href");
    selector = hrefAttr && hrefAttr !== "#" ? hrefAttr.trim() : null;
  }
  return selector;
};
const getSelectorFromElement = (element2) => {
  const selector = getSelector$1(element2);
  if (selector) {
    return document.querySelector(selector) ? selector : null;
  }
  return null;
};
const getElementFromSelector = (element2) => {
  const selector = getSelector$1(element2);
  return selector ? document.querySelector(selector) : null;
};
const isElement$2 = (obj) => {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (typeof obj.jquery !== "undefined") {
    obj = obj[0];
  }
  return typeof obj.nodeType !== "undefined";
};
const getElement$1 = (obj) => {
  if (isElement$2(obj)) {
    return obj.jquery ? obj[0] : obj;
  }
  if (typeof obj === "string" && obj.length > 0) {
    return document.querySelector(obj);
  }
  return null;
};
const typeCheckConfig = (componentName, config, configTypes) => {
  Object.keys(configTypes).forEach((property) => {
    const expectedTypes = configTypes[property];
    const value = config[property];
    const valueType = value && isElement$2(value) ? "element" : toType$1(value);
    if (!new RegExp(expectedTypes).test(valueType)) {
      throw new Error(
        `${componentName.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`
      );
    }
  });
};
const isVisible$1 = (element2) => {
  if (!element2) {
    return false;
  }
  if (element2.style && element2.parentNode && element2.parentNode.style) {
    const elementStyle = getComputedStyle(element2);
    const parentNodeStyle = getComputedStyle(element2.parentNode);
    return elementStyle.display !== "none" && parentNodeStyle.display !== "none" && elementStyle.visibility !== "hidden";
  }
  return false;
};
const isDisabled$1 = (element2) => {
  if (!element2 || element2.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }
  if (element2.classList.contains("disabled")) {
    return true;
  }
  if (typeof element2.disabled !== "undefined") {
    return element2.disabled;
  }
  return element2.hasAttribute("disabled") && element2.getAttribute("disabled") !== "false";
};
const getjQuery$1 = () => {
  const { jQuery } = window;
  if (jQuery && !document.body.hasAttribute("data-mdb-no-jquery")) {
    return jQuery;
  }
  return null;
};
const onDOMContentLoaded = (callback) => {
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", callback);
  } else {
    callback();
  }
};
document.documentElement.dir === "rtl";
const element = (tag) => {
  return document.createElement(tag);
};
const defineJQueryPlugin = (plugin) => {
  onDOMContentLoaded(() => {
    const $2 = getjQuery$1();
    if ($2) {
      const name = plugin.NAME;
      const JQUERY_NO_CONFLICT = $2.fn[name];
      $2.fn[name] = plugin.jQueryInterface;
      $2.fn[name].Constructor = plugin;
      $2.fn[name].noConflict = () => {
        $2.fn[name] = JQUERY_NO_CONFLICT;
        return plugin.jQueryInterface;
      };
    }
  });
};
const $ = getjQuery$1();
const namespaceRegex$1 = /[^.]*(?=\..*)\.|.*/;
const stripNameRegex$1 = /\..*/;
const stripUidRegex$1 = /::\d+$/;
const eventRegistry$1 = {};
let uidEvent$1 = 1;
const customEvents$1 = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
};
const nativeEvents$1 = [
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
];
function getUidEvent(element2, uid) {
  return uid && `${uid}::${uidEvent$1++}` || element2.uidEvent || uidEvent$1++;
}
function getEvent(element2) {
  const uid = getUidEvent(element2);
  element2.uidEvent = uid;
  eventRegistry$1[uid] = eventRegistry$1[uid] || {};
  return eventRegistry$1[uid];
}
function bootstrapHandler$1(element2, fn2) {
  return function handler(event) {
    event.delegateTarget = element2;
    if (handler.oneOff) {
      EventHandler$1.off(element2, event.type, fn2);
    }
    return fn2.apply(element2, [event]);
  };
}
function bootstrapDelegationHandler$1(element2, selector, fn2) {
  return function handler(event) {
    const domElements = element2.querySelectorAll(selector);
    for (let { target } = event; target && target !== this; target = target.parentNode) {
      for (let i = domElements.length; i--; "") {
        if (domElements[i] === target) {
          event.delegateTarget = target;
          if (handler.oneOff) {
            EventHandler$1.off(element2, event.type, fn2);
          }
          return fn2.apply(target, [event]);
        }
      }
    }
    return null;
  };
}
function findHandler$1(events, handler, delegationSelector = null) {
  const uidEventList = Object.keys(events);
  for (let i = 0, len = uidEventList.length; i < len; i++) {
    const event = events[uidEventList[i]];
    if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {
      return event;
    }
  }
  return null;
}
function normalizeParams(originalTypeEvent, handler, delegationFn) {
  const delegation = typeof handler === "string";
  const originalHandler = delegation ? delegationFn : handler;
  let typeEvent = originalTypeEvent.replace(stripNameRegex$1, "");
  const custom = customEvents$1[typeEvent];
  if (custom) {
    typeEvent = custom;
  }
  const isNative = nativeEvents$1.indexOf(typeEvent) > -1;
  if (!isNative) {
    typeEvent = originalTypeEvent;
  }
  return [delegation, originalHandler, typeEvent];
}
function addHandler$1(element2, originalTypeEvent, handler, delegationFn, oneOff) {
  if (typeof originalTypeEvent !== "string" || !element2) {
    return;
  }
  if (!handler) {
    handler = delegationFn;
    delegationFn = null;
  }
  const [delegation, originalHandler, typeEvent] = normalizeParams(